{
    "$schema": "https://ui.shadcn.com/schema/registry-item.json",
    "name": "fuzzy",
    "title": "fuzzy",
    "description": "A fuzzy text component designed with React and Tailwind CSS.",
    "author": "Nazmul Hossain",
    "type": "registry:ui",
    "dependencies": [],
    "devDependencies": [],
    "registryDependencies": [],
    "cssVars": {
      "dark": {},
      "light": {}
    },
    "files": [
      {
        "path": "fuzzy.tsx",
         "content": "'use client';\nimport React, { useEffect, useRef, useState, useCallback } from \"react\";\n\n\nconst getNumericFontSize = (fontSize: string | number): number => {\n  if (typeof fontSize === \"number\") {\n    return fontSize;\n  }\n\n  const temp = document.createElement(\"span\");\n  temp.style.fontSize = fontSize;\n  temp.style.position = 'absolute'; // Prevent layout shift\n  temp.style.visibility = 'hidden'; // Keep it off-screen\n  document.body.appendChild(temp);\n  const computedSize = window.getComputedStyle(temp).fontSize;\n  document.body.removeChild(temp);\n  return parseFloat(computedSize);\n};\n\n\n\ninterface FuzzyTextProps {\n  children: React.ReactNode;\n  fontSize?: string | number;\n  fontWeight?: number;\n  fontFamily?: string;\n  color?: string;\n  enableHover?: boolean;\n  baseIntensity?: number;\n  hoverIntensity?: number;\n}\n\n// --- FuzzyText Component ---\nconst FuzzyText: React.FC<FuzzyTextProps> = ({\n  children,\n  fontSize = \"clamp(2rem, 10vw, 10rem)\",\n  fontWeight = 900,\n  fontFamily = \"inherit\",\n  color = \"#fff\",\n  enableHover = true,\n  baseIntensity = 0.18,\n  hoverIntensity = 0.5,\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const offscreenCanvasRef = useRef<HTMLCanvasElement | null>(null); \n  const [isHovering, setIsHovering] = useState(false);\n  const text = React.Children.toArray(children).join(\"\");\n\n  // Memoize the animation logic to prevent re-creation on every render\n  const runAnimation = useCallback((\n    ctx: CanvasRenderingContext2D,\n    offscreenCanvas: HTMLCanvasElement,\n    tightHeight: number,\n    offscreenWidth: number\n  ) => {\n    let animationFrameId: number;\n\n    const animate = () => {\n      if (!ctx || !offscreenCanvas) return;\n\n      const fuzzRange = 30; // How far the pixels can be displaced\n\n      // Clear the previous frame with a buffer for the fuzz effect\n      ctx.clearRect(\n        -fuzzRange,\n        -fuzzRange,\n        offscreenWidth + 2 * fuzzRange,\n        tightHeight + 2 * fuzzRange\n      );\n\n      // Determine the intensity of the fuzz effect based on hover state\n      const intensity = isHovering ? hoverIntensity : baseIntensity;\n\n      // Loop through each horizontal slice of the pre-rendered text\n      for (let j = 0; j < tightHeight; j++) {\n        // Calculate a random horizontal displacement for the slice\n        const dx = Math.floor(intensity * (Math.random() - 0.5) * fuzzRange);\n        \n        // Draw the 1px-high slice from the offscreen canvas to the visible canvas\n        // at the displaced position. This creates the \"fuzzy\" or \"glitch\" effect.\n        ctx.drawImage(\n          offscreenCanvas,\n          0, j, // Source x, y\n          offscreenWidth, 1, // Source width, height\n          dx, j, // Destination x, y\n          offscreenWidth, 1 // Destination width, height\n        );\n      }\n\n      // Request the next frame to continue the animation loop\n      animationFrameId = window.requestAnimationFrame(animate);\n    };\n\n    animate();\n\n    // Return a cleanup function to cancel the animation frame\n    return () => window.cancelAnimationFrame(animationFrameId);\n  }, [isHovering, baseIntensity, hoverIntensity]);\n\n\n  // Effect for setting up and drawing on the canvas\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    let isCancelled = false;\n    let cleanupAnimation = () => {};\n\n    const init = async () => {\n      // Ensure custom fonts are loaded before we measure the text\n      if (document.fonts?.ready) {\n        await document.fonts.ready;\n      }\n      if (isCancelled) return;\n\n      const ctx = canvas.getContext(\"2d\");\n      if (!ctx) return;\n\n      // --- Font & Text Measurement ---\n      const resolvedFontFamily = fontFamily === \"inherit\"\n        ? window.getComputedStyle(canvas).fontFamily || \"sans-serif\"\n        : fontFamily;\n      const fontSizeStr = typeof fontSize === \"number\" ? `${fontSize}px` : fontSize;\n      const numericFontSize = getNumericFontSize(fontSize);\n      \n      // Create an offscreen canvas for pre-rendering the text\n      const offscreen = offscreenCanvasRef.current || document.createElement(\"canvas\");\n      offscreenCanvasRef.current = offscreen;\n      const offCtx = offscreen.getContext(\"2d\");\n      if (!offCtx) return;\n\n      // Configure the offscreen context for text measurement\n      offCtx.font = `${fontWeight} ${fontSizeStr} ${resolvedFontFamily}`;\n      offCtx.textBaseline = \"alphabetic\";\n      const metrics = offCtx.measureText(text);\n\n      // Calculate tight bounding box for the text to avoid extra whitespace\n      const actualLeft = metrics.actualBoundingBoxLeft ?? 0;\n      const actualRight = metrics.actualBoundingBoxRight ?? metrics.width;\n      const actualAscent = metrics.actualBoundingBoxAscent ?? numericFontSize;\n      const actualDescent = metrics.actualBoundingBoxDescent ?? numericFontSize * 0.2;\n      const textBoundingWidth = Math.ceil(actualLeft + actualRight);\n      const tightHeight = Math.ceil(actualAscent + actualDescent);\n\n      // --- Pre-render Text to Offscreen Canvas ---\n      const extraWidthBuffer = 10; // Small buffer for rendering artifacts\n      const offscreenWidth = textBoundingWidth + extraWidthBuffer;\n      offscreen.width = offscreenWidth;\n      offscreen.height = tightHeight;\n\n      // Re-apply font settings as resizing the canvas can reset them\n      offCtx.font = `${fontWeight} ${fontSizeStr} ${resolvedFontFamily}`;\n      offCtx.textBaseline = \"alphabetic\";\n      offCtx.fillStyle = color;\n      offCtx.fillText(text, extraWidthBuffer / 2 - actualLeft, actualAscent);\n\n      // --- Setup Main Canvas ---\n      const horizontalMargin = 50; // Margin for the fuzz effect to not get clipped\n      const verticalMargin = 0;\n      canvas.width = offscreenWidth + horizontalMargin * 2;\n      canvas.height = tightHeight + verticalMargin * 2;\n      ctx.translate(horizontalMargin, verticalMargin); // Center the drawing area\n\n      // Start the animation loop\n      cleanupAnimation = runAnimation(ctx, offscreen, tightHeight, offscreenWidth);\n    };\n\n    init();\n\n    return () => {\n      isCancelled = true;\n      cleanupAnimation();\n    };\n  }, [\n    text,\n    fontSize,\n    fontWeight,\n    fontFamily,\n    color,\n    runAnimation,\n  ]);\n\n  // Effect for handling mouse and touch interactions\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas || !enableHover) return;\n\n    const rect = canvas.getBoundingClientRect();\n\n    const handleMove = (clientX: number, clientY: number) => {\n      const x = clientX - rect.left;\n      const y = clientY - rect.top;\n      // A simple check if the cursor is within the canvas bounds\n      setIsHovering(x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height);\n    };\n\n    const handleMouseMove = (e: MouseEvent) => handleMove(e.clientX, e.clientY);\n    const handleTouchMove = (e: TouchEvent) => {\n      e.preventDefault();\n      const touch = e.touches[0];\n      if (touch) {\n        handleMove(touch.clientX, touch.clientY);\n      }\n    };\n\n    const handleLeave = () => setIsHovering(false);\n\n    canvas.addEventListener(\"mousemove\", handleMouseMove);\n    canvas.addEventListener(\"mouseleave\", handleLeave);\n    canvas.addEventListener(\"touchmove\", handleTouchMove, { passive: false });\n    canvas.addEventListener(\"touchend\", handleLeave);\n\n    return () => {\n      canvas.removeEventListener(\"mousemove\", handleMouseMove);\n      canvas.removeEventListener(\"mouseleave\", handleLeave);\n      canvas.removeEventListener(\"touchmove\", handleTouchMove);\n      canvas.removeEventListener(\"touchend\", handleLeave);\n    };\n  }, [enableHover]);\n\n  return <canvas ref={canvasRef} style={{ maxWidth: '100%' }} />;\n};\n\n\n// --- Main App Component to showcase FuzzyText ---\nexport default function Fuzzy() {\n  return (\n    <div className=\"w-full flex flex-col items-center justify-center p-4 font-sans\">\n      <FuzzyText\n        fontSize=\"clamp(3rem, 12vw, 12rem)\"\n        fontWeight={900}\n        baseIntensity={0.15}\n        hoverIntensity={0.6}\n        color=\"#00ff99\"\n      >\n        HOVER ME\n      </FuzzyText>\n    </div>\n  );\n}\n",
        "type": "registry:ui"
      }
    ]
  }
  