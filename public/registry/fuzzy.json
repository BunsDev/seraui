{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "fuzzy",
  "title": "Fuzzy",
  "description": "A minimalistic fuzzy search component designed with React and Tailwind CSS.",
  "author": "Reche Soares",
  "type": "registry:ui",
  "dependencies": [],
  "devDependencies": [],
  "registryDependencies": [],
  "cssVars": {
    "dark": {},
    "light": {}
  },
  "files": [
    {
      "path": "fuzzy.tsx",
      "content": "'use client';\r\nimport React, { useEffect, useRef, useState, useCallback } from \"react\";\r\n\r\n\r\nconst getNumericFontSize = (fontSize: string | number): number => {\r\n  if (typeof fontSize === \"number\") {\r\n    return fontSize;\r\n  }\r\n\r\n  const temp = document.createElement(\"span\");\r\n  temp.style.fontSize = fontSize;\r\n  temp.style.position = 'absolute'; // Prevent layout shift\r\n  temp.style.visibility = 'hidden'; // Keep it off-screen\r\n  document.body.appendChild(temp);\r\n  const computedSize = window.getComputedStyle(temp).fontSize;\r\n  document.body.removeChild(temp);\r\n  return parseFloat(computedSize);\r\n};\r\n\r\n\r\n\r\ninterface FuzzyTextProps {\r\n  children: React.ReactNode;\r\n  fontSize?: string | number;\r\n  fontWeight?: number;\r\n  fontFamily?: string;\r\n  color?: string;\r\n  enableHover?: boolean;\r\n  baseIntensity?: number;\r\n  hoverIntensity?: number;\r\n}\r\n\r\n// --- FuzzyText Component ---\r\nconst FuzzyText: React.FC<FuzzyTextProps> = ({\r\n  children,\r\n  fontSize = \"clamp(2rem, 10vw, 10rem)\",\r\n  fontWeight = 900,\r\n  fontFamily = \"inherit\",\r\n  color = \"#fff\",\r\n  enableHover = true,\r\n  baseIntensity = 0.18,\r\n  hoverIntensity = 0.5,\r\n}) => {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n  const offscreenCanvasRef = useRef<HTMLCanvasElement | null>(null); \r\n  const [isHovering, setIsHovering] = useState(false);\r\n  const text = React.Children.toArray(children).join(\"\");\r\n\r\n  // Memoize the animation logic to prevent re-creation on every render\r\n  const runAnimation = useCallback((\r\n    ctx: CanvasRenderingContext2D,\r\n    offscreenCanvas: HTMLCanvasElement,\r\n    tightHeight: number,\r\n    offscreenWidth: number\r\n  ) => {\r\n    let animationFrameId: number;\r\n\r\n    const animate = () => {\r\n      if (!ctx || !offscreenCanvas) return;\r\n\r\n      const fuzzRange = 30; // How far the pixels can be displaced\r\n\r\n      // Clear the previous frame with a buffer for the fuzz effect\r\n      ctx.clearRect(\r\n        -fuzzRange,\r\n        -fuzzRange,\r\n        offscreenWidth + 2 * fuzzRange,\r\n        tightHeight + 2 * fuzzRange\r\n      );\r\n\r\n      // Determine the intensity of the fuzz effect based on hover state\r\n      const intensity = isHovering ? hoverIntensity : baseIntensity;\r\n\r\n      // Loop through each horizontal slice of the pre-rendered text\r\n      for (let j = 0; j < tightHeight; j++) {\r\n        // Calculate a random horizontal displacement for the slice\r\n        const dx = Math.floor(intensity * (Math.random() - 0.5) * fuzzRange);\r\n        \r\n        // Draw the 1px-high slice from the offscreen canvas to the visible canvas\r\n        // at the displaced position. This creates the \"fuzzy\" or \"glitch\" effect.\r\n        ctx.drawImage(\r\n          offscreenCanvas,\r\n          0, j, // Source x, y\r\n          offscreenWidth, 1, // Source width, height\r\n          dx, j, // Destination x, y\r\n          offscreenWidth, 1 // Destination width, height\r\n        );\r\n      }\r\n\r\n      // Request the next frame to continue the animation loop\r\n      animationFrameId = window.requestAnimationFrame(animate);\r\n    };\r\n\r\n    animate();\r\n\r\n    // Return a cleanup function to cancel the animation frame\r\n    return () => window.cancelAnimationFrame(animationFrameId);\r\n  }, [isHovering, baseIntensity, hoverIntensity]);\r\n\r\n\r\n  // Effect for setting up and drawing on the canvas\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    let isCancelled = false;\r\n    let cleanupAnimation = () => {};\r\n\r\n    const init = async () => {\r\n      // Ensure custom fonts are loaded before we measure the text\r\n      if (document.fonts?.ready) {\r\n        await document.fonts.ready;\r\n      }\r\n      if (isCancelled) return;\r\n\r\n      const ctx = canvas.getContext(\"2d\");\r\n      if (!ctx) return;\r\n\r\n      // --- Font & Text Measurement ---\r\n      const resolvedFontFamily = fontFamily === \"inherit\"\r\n        ? window.getComputedStyle(canvas).fontFamily || \"sans-serif\"\r\n        : fontFamily;\r\n      const fontSizeStr = typeof fontSize === \"number\" ? `${fontSize}px` : fontSize;\r\n      const numericFontSize = getNumericFontSize(fontSize);\r\n      \r\n      // Create an offscreen canvas for pre-rendering the text\r\n      const offscreen = offscreenCanvasRef.current || document.createElement(\"canvas\");\r\n      offscreenCanvasRef.current = offscreen;\r\n      const offCtx = offscreen.getContext(\"2d\");\r\n      if (!offCtx) return;\r\n\r\n      // Configure the offscreen context for text measurement\r\n      offCtx.font = `${fontWeight} ${fontSizeStr} ${resolvedFontFamily}`;\r\n      offCtx.textBaseline = \"alphabetic\";\r\n      const metrics = offCtx.measureText(text);\r\n\r\n      // Calculate tight bounding box for the text to avoid extra whitespace\r\n      const actualLeft = metrics.actualBoundingBoxLeft ?? 0;\r\n      const actualRight = metrics.actualBoundingBoxRight ?? metrics.width;\r\n      const actualAscent = metrics.actualBoundingBoxAscent ?? numericFontSize;\r\n      const actualDescent = metrics.actualBoundingBoxDescent ?? numericFontSize * 0.2;\r\n      const textBoundingWidth = Math.ceil(actualLeft + actualRight);\r\n      const tightHeight = Math.ceil(actualAscent + actualDescent);\r\n\r\n      // --- Pre-render Text to Offscreen Canvas ---\r\n      const extraWidthBuffer = 10; // Small buffer for rendering artifacts\r\n      const offscreenWidth = textBoundingWidth + extraWidthBuffer;\r\n      offscreen.width = offscreenWidth;\r\n      offscreen.height = tightHeight;\r\n\r\n      // Re-apply font settings as resizing the canvas can reset them\r\n      offCtx.font = `${fontWeight} ${fontSizeStr} ${resolvedFontFamily}`;\r\n      offCtx.textBaseline = \"alphabetic\";\r\n      offCtx.fillStyle = color;\r\n      offCtx.fillText(text, extraWidthBuffer / 2 - actualLeft, actualAscent);\r\n\r\n      // --- Setup Main Canvas ---\r\n      const horizontalMargin = 50; // Margin for the fuzz effect to not get clipped\r\n      const verticalMargin = 0;\r\n      canvas.width = offscreenWidth + horizontalMargin * 2;\r\n      canvas.height = tightHeight + verticalMargin * 2;\r\n      ctx.translate(horizontalMargin, verticalMargin); // Center the drawing area\r\n\r\n      // Start the animation loop\r\n      cleanupAnimation = runAnimation(ctx, offscreen, tightHeight, offscreenWidth);\r\n    };\r\n\r\n    init();\r\n\r\n    return () => {\r\n      isCancelled = true;\r\n      cleanupAnimation();\r\n    };\r\n  }, [\r\n    text,\r\n    fontSize,\r\n    fontWeight,\r\n    fontFamily,\r\n    color,\r\n    runAnimation,\r\n  ]);\r\n\r\n  // Effect for handling mouse and touch interactions\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas || !enableHover) return;\r\n\r\n    const rect = canvas.getBoundingClientRect();\r\n\r\n    const handleMove = (clientX: number, clientY: number) => {\r\n      const x = clientX - rect.left;\r\n      const y = clientY - rect.top;\r\n      // A simple check if the cursor is within the canvas bounds\r\n      setIsHovering(x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height);\r\n    };\r\n\r\n    const handleMouseMove = (e: MouseEvent) => handleMove(e.clientX, e.clientY);\r\n    const handleTouchMove = (e: TouchEvent) => {\r\n      e.preventDefault();\r\n      const touch = e.touches[0];\r\n      if (touch) {\r\n        handleMove(touch.clientX, touch.clientY);\r\n      }\r\n    };\r\n\r\n    const handleLeave = () => setIsHovering(false);\r\n\r\n    canvas.addEventListener(\"mousemove\", handleMouseMove);\r\n    canvas.addEventListener(\"mouseleave\", handleLeave);\r\n    canvas.addEventListener(\"touchmove\", handleTouchMove, { passive: false });\r\n    canvas.addEventListener(\"touchend\", handleLeave);\r\n\r\n    return () => {\r\n      canvas.removeEventListener(\"mousemove\", handleMouseMove);\r\n      canvas.removeEventListener(\"mouseleave\", handleLeave);\r\n      canvas.removeEventListener(\"touchmove\", handleTouchMove);\r\n      canvas.removeEventListener(\"touchend\", handleLeave);\r\n    };\r\n  }, [enableHover]);\r\n\r\n  return <canvas ref={canvasRef} style={{ maxWidth: '100%' }} />;\r\n};\r\n\r\n\r\n// --- Main App Component to showcase FuzzyText ---\r\nexport default function Fuzzy() {\r\n  return (\r\n    <div className=\"w-full flex flex-col items-center justify-center p-4 font-sans\">\r\n      <FuzzyText\r\n        fontSize=\"clamp(3rem, 12vw, 12rem)\"\r\n        fontWeight={900}\r\n        baseIntensity={0.15}\r\n        hoverIntensity={0.6}\r\n        color=\"#00ff99\"\r\n      >\r\n        HOVER ME\r\n      </FuzzyText>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:ui"
    }
  ]
}